/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,ts_nocheck,eslint_disable
// @generated from protobuf file "baboon/service.proto" (package "ttab.baboon", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Document } from "../newsdoc/newsdoc";
/**
 * @generated from protobuf message ttab.baboon.CreateFlowRequest
 */
export interface CreateFlowRequest {
    /**
     * FlowUuid to instantiate on the given date. Required.
     *
     * @generated from protobuf field: string flow_uuid = 1;
     */
    flowUuid: string;
    /**
     * Date to instantiate the flow on in the format YYYY-MM-DD. Required.
     *
     * @generated from protobuf field: string date = 2;
     */
    date: string;
    /**
     * Articles to instantiate. Names of the defined print contents in the
     * flow. Optional, omit to instantiate all.
     *
     * @generated from protobuf field: repeated string articles = 3;
     */
    articles: string[];
}
/**
 * @generated from protobuf message ttab.baboon.CreateFlowResponse
 */
export interface CreateFlowResponse {
    /**
     * Articles that were created.
     *
     * @generated from protobuf field: repeated ttab.baboon.PrintArticleReference articles = 1;
     */
    articles: PrintArticleReference[];
}
/**
 * @generated from protobuf message ttab.baboon.PrintArticleReference
 */
export interface PrintArticleReference {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message ttab.baboon.CopyArticleToFlowRequest
 */
export interface CopyArticleToFlowRequest {
    /**
     * SourceUuid is the UUID of the article that we want to copy. Required.
     *
     * @generated from protobuf field: string source_uuid = 1;
     */
    sourceUuid: string;
    /**
     * FlowUuid to copy the article to. Required.
     *
     * @generated from protobuf field: string flow_uuid = 2;
     */
    flowUuid: string;
    /**
     * Date to set for the copy on in the format YYYY-MM-DD. Required.
     *
     * @generated from protobuf field: string date = 3;
     */
    date: string;
    /**
     * Article is the name of the defined print content in the flow to
     * instantiate. Required.
     *
     * @generated from protobuf field: string article = 4;
     */
    article: string;
}
/**
 * @generated from protobuf message ttab.baboon.CopyArticleToFlowResponse
 */
export interface CopyArticleToFlowResponse {
    /**
     * Uuid of the created article.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message ttab.baboon.GetScribusInfoRequest
 */
export interface GetScribusInfoRequest {
    /**
     * Uuid of the layout document to get information for. Required.
     *
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
}
/**
 * @generated from protobuf message ttab.baboon.GetScribusInfoResponse
 */
export interface GetScribusInfoResponse {
    /**
     * @generated from protobuf field: repeated ttab.baboon.ScribusDependency fonts = 1;
     */
    fonts: ScribusDependency[];
    /**
     * @generated from protobuf field: repeated ttab.baboon.ScribusDependency icc_profiles = 2;
     */
    iccProfiles: ScribusDependency[];
    /**
     * @generated from protobuf field: repeated string slots = 3;
     */
    slots: string[];
    /**
     * @generated from protobuf field: repeated ttab.baboon.ScribusLayer layers = 4;
     */
    layers: ScribusLayer[];
}
/**
 * @generated from protobuf message ttab.baboon.ScribusLayer
 */
export interface ScribusLayer {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string slot = 3;
     */
    slot: string;
    /**
     * @generated from protobuf field: repeated ttab.baboon.ScribusFrame frames = 4;
     */
    frames: ScribusFrame[];
}
/**
 * @generated from protobuf message ttab.baboon.ScribusFrame
 */
export interface ScribusFrame {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string slot = 2;
     */
    slot: string;
    /**
     * @generated from protobuf field: ttab.baboon.FrameType type = 3;
     */
    type: FrameType;
}
/**
 * @generated from protobuf message ttab.baboon.ScribusDependency
 */
export interface ScribusDependency {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bool satisfied = 2;
     */
    satisfied: boolean;
}
/**
 * @generated from protobuf message ttab.baboon.StoreFontRequest
 */
export interface StoreFontRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: string filename = 3;
     */
    filename: string;
    /**
     * @generated from protobuf field: bytes file = 4;
     */
    file: Uint8Array;
}
/**
 * @generated from protobuf message ttab.baboon.StoreFontResponse
 */
export interface StoreFontResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
/**
 * @generated from protobuf message ttab.baboon.GetFontsRequest
 */
export interface GetFontsRequest {
    /**
     * Fonts to load, maximum of 20 fonts per batch.
     *
     * @generated from protobuf field: repeated ttab.baboon.FontRef fonts = 1;
     */
    fonts: FontRef[];
}
/**
 * @generated from protobuf message ttab.baboon.FontRef
 */
export interface FontRef {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * IfNotVersion can be used to only return a font if it hasn't been updated.
     *
     * @generated from protobuf field: string if_not_version = 2;
     */
    ifNotVersion: string;
}
/**
 * @generated from protobuf message ttab.baboon.GetFontsResponse
 */
export interface GetFontsResponse {
    /**
     * @generated from protobuf field: repeated ttab.baboon.Font fonts = 1;
     */
    fonts: Font[];
}
/**
 * @generated from protobuf message ttab.baboon.Font
 */
export interface Font {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 3;
     */
    version: string;
    /**
     * @generated from protobuf field: string description = 4;
     */
    description: string;
    /**
     * @generated from protobuf field: bytes file = 5;
     */
    file: Uint8Array;
}
/**
 * @generated from protobuf message ttab.baboon.ListFontsRequest
 */
export interface ListFontsRequest {
    /**
     * @generated from protobuf field: int64 page = 1;
     */
    page: bigint;
}
/**
 * @generated from protobuf message ttab.baboon.ListFontsResponse
 */
export interface ListFontsResponse {
    /**
     * @generated from protobuf field: repeated ttab.baboon.FontInfo items = 1;
     */
    items: FontInfo[];
    /**
     * @generated from protobuf field: int64 next_page = 2;
     */
    nextPage: bigint;
}
/**
 * @generated from protobuf message ttab.baboon.FontInfo
 */
export interface FontInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * @generated from protobuf message ttab.baboon.DeleteFontRequest
 */
export interface DeleteFontRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message ttab.baboon.DeleteFontResponse
 */
export interface DeleteFontResponse {
}
/**
 * @generated from protobuf message ttab.baboon.StoreICCProfileRequest
 */
export interface StoreICCProfileRequest {
    /**
     * Name is optional, will be extracted from ICC data if not provided. Setting
     * a name for the profile that differs from the one in the ICC data will not
     * make Scribus resolve it correctly. Forcing a different name should only be
     * done if baboon cannot parse the ICC file correctly.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: bytes file = 3;
     */
    file: Uint8Array;
}
/**
 * @generated from protobuf message ttab.baboon.StoreICCProfileResponse
 */
export interface StoreICCProfileResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
/**
 * @generated from protobuf message ttab.baboon.ListICCProfilesRequest
 */
export interface ListICCProfilesRequest {
    /**
     * @generated from protobuf field: int64 page = 1;
     */
    page: bigint;
}
/**
 * @generated from protobuf message ttab.baboon.ListICCProfilesResponse
 */
export interface ListICCProfilesResponse {
    /**
     * @generated from protobuf field: repeated ttab.baboon.ICCProfileInfo items = 1;
     */
    items: ICCProfileInfo[];
    /**
     * @generated from protobuf field: int64 next_page = 2;
     */
    nextPage: bigint;
}
/**
 * @generated from protobuf message ttab.baboon.ICCProfileInfo
 */
export interface ICCProfileInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
}
/**
 * @generated from protobuf message ttab.baboon.RenderArticleRequest
 */
export interface RenderArticleRequest {
    /**
     * ArticleUuid is the UUID of the print article to render. Required.
     *
     * @generated from protobuf field: string article_uuid = 1;
     */
    articleUuid: string;
    /**
     * LayoutId is the ID of the article layout to render. Required.
     *
     * @generated from protobuf field: string layout_id = 2;
     */
    layoutId: string;
    /**
     * RenderPDF will enable PDF rendering.
     *
     * @generated from protobuf field: bool render_pdf = 3;
     */
    renderPdf: boolean;
    /**
     * RenderPDF will enable PNG rendering.
     *
     * @generated from protobuf field: bool render_png = 4;
     */
    renderPng: boolean;
    /**
     * PngScale is the DPI of the rendered PDF. Defaults to 200.
     *
     * @generated from protobuf field: int64 png_scale = 5;
     */
    pngScale: bigint;
}
/**
 * @generated from protobuf message ttab.baboon.RenderArticleResponse
 */
export interface RenderArticleResponse {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: string pdf_url = 2;
     */
    pdfUrl: string;
    /**
     * @generated from protobuf field: string png_url = 3;
     */
    pngUrl: string;
    /**
     * @generated from protobuf field: string scribus_url = 4;
     */
    scribusUrl: string;
    /**
     * @generated from protobuf field: int32 png_width = 5;
     */
    pngWidth: number;
    /**
     * @generated from protobuf field: int32 png_height = 6;
     */
    pngHeight: number;
    /**
     * Images that were mounted.
     *
     * @generated from protobuf field: repeated ttab.baboon.MountedImage images = 7;
     */
    images: MountedImage[];
    /**
     * Overflows is a list of text frames whose contents overflowed the frame.
     *
     * @generated from protobuf field: repeated ttab.baboon.Overflow overflows = 8;
     */
    overflows: Overflow[];
}
/**
 * @generated from protobuf message ttab.baboon.MountedImage
 */
export interface MountedImage {
    /**
     * Frame name that was used for the image.
     *
     * @generated from protobuf field: string frame = 1;
     */
    frame: string;
    /**
     * BoundingBox for the image in 0.0-1.0 coordinates relative to the page width
     * and height.
     *
     * @generated from protobuf field: ttab.baboon.Rect bounding_box = 2;
     */
    boundingBox?: Rect;
    /**
     * PPI before any PDF downsampling was applied.
     *
     * @generated from protobuf field: double ppi = 3;
     */
    ppi: number;
}
/**
 * @generated from protobuf message ttab.baboon.Overflow
 */
export interface Overflow {
    /**
     * Frame name that overflowed.
     *
     * @generated from protobuf field: string frame = 1;
     */
    frame: string;
    /**
     * BoundingBox for the frame in 0.0-1.0 coordinates relative to the page width
     * and height.
     *
     * @generated from protobuf field: ttab.baboon.Rect bounding_box = 2;
     */
    boundingBox?: Rect;
}
/**
 * @generated from protobuf message ttab.baboon.Rect
 */
export interface Rect {
    /**
     * @generated from protobuf field: double x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: double width = 3;
     */
    width: number;
    /**
     * @generated from protobuf field: double height = 4;
     */
    height: number;
}
/**
 * @generated from protobuf message ttab.baboon.GetEditableArchiveRequest
 */
export interface GetEditableArchiveRequest {
    /**
     * @generated from protobuf field: int64 render_id = 1;
     */
    renderId: bigint;
}
/**
 * @generated from protobuf message ttab.baboon.GetEditableArchiveResponse
 */
export interface GetEditableArchiveResponse {
}
/**
 * @generated from protobuf message ttab.baboon.LayoutPreviewRequest
 */
export interface LayoutPreviewRequest {
    /**
     * @generated from protobuf field: string sla_file = 1;
     */
    slaFile: string;
    /**
     * @generated from protobuf field: newsdoc.Document layout = 2;
     */
    layout?: Document;
    /**
     * @generated from protobuf field: string content_uuid = 3;
     */
    contentUuid: string;
    /**
     * @generated from protobuf field: newsdoc.Document content = 4;
     */
    content?: Document;
    /**
     * @generated from protobuf field: string article_layout = 5;
     */
    articleLayout: string;
    /**
     * @generated from protobuf field: map<string, bool> features = 6;
     */
    features: {
        [key: string]: boolean;
    };
}
/**
 * @generated from protobuf message ttab.baboon.LayoutPreviewResponse
 */
export interface LayoutPreviewResponse {
    /**
     * PDFData produced by the render.
     *
     * @generated from protobuf field: bytes pdf_data = 1;
     */
    pdfData: Uint8Array;
    /**
     * Images that were mounted.
     *
     * @generated from protobuf field: repeated ttab.baboon.MountedImage images = 2;
     */
    images: MountedImage[];
    /**
     * Overflows is a list of text frames whose contents overflowed the frame.
     *
     * @generated from protobuf field: repeated ttab.baboon.Overflow overflows = 3;
     */
    overflows: Overflow[];
    /**
     * ScribusDoc is the Scribus document used to render the preview.
     *
     * @generated from protobuf field: bytes scribus_doc = 4;
     */
    scribusDoc: Uint8Array;
}
/**
 * @generated from protobuf enum ttab.baboon.FrameType
 */
export enum FrameType {
    /**
     * @generated from protobuf enum value: FRAME_UNKNOWN = 0;
     */
    FRAME_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: FRAME_TEXT = 1;
     */
    FRAME_TEXT = 1,
    /**
     * @generated from protobuf enum value: FRAME_IMAGE = 2;
     */
    FRAME_IMAGE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateFlowRequest$Type extends MessageType<CreateFlowRequest> {
    constructor() {
        super("ttab.baboon.CreateFlowRequest", [
            { no: 1, name: "flow_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "articles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateFlowRequest>): CreateFlowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flowUuid = "";
        message.date = "";
        message.articles = [];
        if (value !== undefined)
            reflectionMergePartial<CreateFlowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateFlowRequest): CreateFlowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string flow_uuid */ 1:
                    message.flowUuid = reader.string();
                    break;
                case /* string date */ 2:
                    message.date = reader.string();
                    break;
                case /* repeated string articles */ 3:
                    message.articles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateFlowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string flow_uuid = 1; */
        if (message.flowUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.flowUuid);
        /* string date = 2; */
        if (message.date !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.date);
        /* repeated string articles = 3; */
        for (let i = 0; i < message.articles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.articles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.CreateFlowRequest
 */
export const CreateFlowRequest = new CreateFlowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateFlowResponse$Type extends MessageType<CreateFlowResponse> {
    constructor() {
        super("ttab.baboon.CreateFlowResponse", [
            { no: 1, name: "articles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PrintArticleReference }
        ]);
    }
    create(value?: PartialMessage<CreateFlowResponse>): CreateFlowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.articles = [];
        if (value !== undefined)
            reflectionMergePartial<CreateFlowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateFlowResponse): CreateFlowResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ttab.baboon.PrintArticleReference articles */ 1:
                    message.articles.push(PrintArticleReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateFlowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ttab.baboon.PrintArticleReference articles = 1; */
        for (let i = 0; i < message.articles.length; i++)
            PrintArticleReference.internalBinaryWrite(message.articles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.CreateFlowResponse
 */
export const CreateFlowResponse = new CreateFlowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrintArticleReference$Type extends MessageType<PrintArticleReference> {
    constructor() {
        super("ttab.baboon.PrintArticleReference", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrintArticleReference>): PrintArticleReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<PrintArticleReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrintArticleReference): PrintArticleReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrintArticleReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.PrintArticleReference
 */
export const PrintArticleReference = new PrintArticleReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyArticleToFlowRequest$Type extends MessageType<CopyArticleToFlowRequest> {
    constructor() {
        super("ttab.baboon.CopyArticleToFlowRequest", [
            { no: 1, name: "source_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "flow_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "article", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CopyArticleToFlowRequest>): CopyArticleToFlowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceUuid = "";
        message.flowUuid = "";
        message.date = "";
        message.article = "";
        if (value !== undefined)
            reflectionMergePartial<CopyArticleToFlowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyArticleToFlowRequest): CopyArticleToFlowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source_uuid */ 1:
                    message.sourceUuid = reader.string();
                    break;
                case /* string flow_uuid */ 2:
                    message.flowUuid = reader.string();
                    break;
                case /* string date */ 3:
                    message.date = reader.string();
                    break;
                case /* string article */ 4:
                    message.article = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyArticleToFlowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source_uuid = 1; */
        if (message.sourceUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sourceUuid);
        /* string flow_uuid = 2; */
        if (message.flowUuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.flowUuid);
        /* string date = 3; */
        if (message.date !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.date);
        /* string article = 4; */
        if (message.article !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.article);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.CopyArticleToFlowRequest
 */
export const CopyArticleToFlowRequest = new CopyArticleToFlowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyArticleToFlowResponse$Type extends MessageType<CopyArticleToFlowResponse> {
    constructor() {
        super("ttab.baboon.CopyArticleToFlowResponse", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CopyArticleToFlowResponse>): CopyArticleToFlowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<CopyArticleToFlowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyArticleToFlowResponse): CopyArticleToFlowResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyArticleToFlowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.CopyArticleToFlowResponse
 */
export const CopyArticleToFlowResponse = new CopyArticleToFlowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScribusInfoRequest$Type extends MessageType<GetScribusInfoRequest> {
    constructor() {
        super("ttab.baboon.GetScribusInfoRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetScribusInfoRequest>): GetScribusInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetScribusInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetScribusInfoRequest): GetScribusInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetScribusInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.GetScribusInfoRequest
 */
export const GetScribusInfoRequest = new GetScribusInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScribusInfoResponse$Type extends MessageType<GetScribusInfoResponse> {
    constructor() {
        super("ttab.baboon.GetScribusInfoResponse", [
            { no: 1, name: "fonts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScribusDependency },
            { no: 2, name: "icc_profiles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScribusDependency },
            { no: 3, name: "slots", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "layers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScribusLayer }
        ]);
    }
    create(value?: PartialMessage<GetScribusInfoResponse>): GetScribusInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fonts = [];
        message.iccProfiles = [];
        message.slots = [];
        message.layers = [];
        if (value !== undefined)
            reflectionMergePartial<GetScribusInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetScribusInfoResponse): GetScribusInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ttab.baboon.ScribusDependency fonts */ 1:
                    message.fonts.push(ScribusDependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ttab.baboon.ScribusDependency icc_profiles */ 2:
                    message.iccProfiles.push(ScribusDependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string slots */ 3:
                    message.slots.push(reader.string());
                    break;
                case /* repeated ttab.baboon.ScribusLayer layers */ 4:
                    message.layers.push(ScribusLayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetScribusInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ttab.baboon.ScribusDependency fonts = 1; */
        for (let i = 0; i < message.fonts.length; i++)
            ScribusDependency.internalBinaryWrite(message.fonts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ttab.baboon.ScribusDependency icc_profiles = 2; */
        for (let i = 0; i < message.iccProfiles.length; i++)
            ScribusDependency.internalBinaryWrite(message.iccProfiles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string slots = 3; */
        for (let i = 0; i < message.slots.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.slots[i]);
        /* repeated ttab.baboon.ScribusLayer layers = 4; */
        for (let i = 0; i < message.layers.length; i++)
            ScribusLayer.internalBinaryWrite(message.layers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.GetScribusInfoResponse
 */
export const GetScribusInfoResponse = new GetScribusInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScribusLayer$Type extends MessageType<ScribusLayer> {
    constructor() {
        super("ttab.baboon.ScribusLayer", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "slot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "frames", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScribusFrame }
        ]);
    }
    create(value?: PartialMessage<ScribusLayer>): ScribusLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.slot = "";
        message.frames = [];
        if (value !== undefined)
            reflectionMergePartial<ScribusLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScribusLayer): ScribusLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string slot */ 3:
                    message.slot = reader.string();
                    break;
                case /* repeated ttab.baboon.ScribusFrame frames */ 4:
                    message.frames.push(ScribusFrame.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScribusLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string slot = 3; */
        if (message.slot !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.slot);
        /* repeated ttab.baboon.ScribusFrame frames = 4; */
        for (let i = 0; i < message.frames.length; i++)
            ScribusFrame.internalBinaryWrite(message.frames[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ScribusLayer
 */
export const ScribusLayer = new ScribusLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScribusFrame$Type extends MessageType<ScribusFrame> {
    constructor() {
        super("ttab.baboon.ScribusFrame", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "slot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["ttab.baboon.FrameType", FrameType] }
        ]);
    }
    create(value?: PartialMessage<ScribusFrame>): ScribusFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.slot = "";
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<ScribusFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScribusFrame): ScribusFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string slot */ 2:
                    message.slot = reader.string();
                    break;
                case /* ttab.baboon.FrameType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScribusFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string slot = 2; */
        if (message.slot !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.slot);
        /* ttab.baboon.FrameType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ScribusFrame
 */
export const ScribusFrame = new ScribusFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScribusDependency$Type extends MessageType<ScribusDependency> {
    constructor() {
        super("ttab.baboon.ScribusDependency", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "satisfied", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ScribusDependency>): ScribusDependency {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.satisfied = false;
        if (value !== undefined)
            reflectionMergePartial<ScribusDependency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScribusDependency): ScribusDependency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool satisfied */ 2:
                    message.satisfied = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScribusDependency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool satisfied = 2; */
        if (message.satisfied !== false)
            writer.tag(2, WireType.Varint).bool(message.satisfied);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ScribusDependency
 */
export const ScribusDependency = new ScribusDependency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreFontRequest$Type extends MessageType<StoreFontRequest> {
    constructor() {
        super("ttab.baboon.StoreFontRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "file", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<StoreFontRequest>): StoreFontRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.description = "";
        message.filename = "";
        message.file = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<StoreFontRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreFontRequest): StoreFontRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string filename */ 3:
                    message.filename = reader.string();
                    break;
                case /* bytes file */ 4:
                    message.file = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreFontRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string filename = 3; */
        if (message.filename !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.filename);
        /* bytes file = 4; */
        if (message.file.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.file);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.StoreFontRequest
 */
export const StoreFontRequest = new StoreFontRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreFontResponse$Type extends MessageType<StoreFontResponse> {
    constructor() {
        super("ttab.baboon.StoreFontResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreFontResponse>): StoreFontResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<StoreFontResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreFontResponse): StoreFontResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreFontResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.StoreFontResponse
 */
export const StoreFontResponse = new StoreFontResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFontsRequest$Type extends MessageType<GetFontsRequest> {
    constructor() {
        super("ttab.baboon.GetFontsRequest", [
            { no: 1, name: "fonts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FontRef }
        ]);
    }
    create(value?: PartialMessage<GetFontsRequest>): GetFontsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fonts = [];
        if (value !== undefined)
            reflectionMergePartial<GetFontsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFontsRequest): GetFontsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ttab.baboon.FontRef fonts */ 1:
                    message.fonts.push(FontRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFontsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ttab.baboon.FontRef fonts = 1; */
        for (let i = 0; i < message.fonts.length; i++)
            FontRef.internalBinaryWrite(message.fonts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.GetFontsRequest
 */
export const GetFontsRequest = new GetFontsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FontRef$Type extends MessageType<FontRef> {
    constructor() {
        super("ttab.baboon.FontRef", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "if_not_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FontRef>): FontRef {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.ifNotVersion = "";
        if (value !== undefined)
            reflectionMergePartial<FontRef>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FontRef): FontRef {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string if_not_version */ 2:
                    message.ifNotVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FontRef, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string if_not_version = 2; */
        if (message.ifNotVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ifNotVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.FontRef
 */
export const FontRef = new FontRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFontsResponse$Type extends MessageType<GetFontsResponse> {
    constructor() {
        super("ttab.baboon.GetFontsResponse", [
            { no: 1, name: "fonts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Font }
        ]);
    }
    create(value?: PartialMessage<GetFontsResponse>): GetFontsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fonts = [];
        if (value !== undefined)
            reflectionMergePartial<GetFontsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFontsResponse): GetFontsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ttab.baboon.Font fonts */ 1:
                    message.fonts.push(Font.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFontsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ttab.baboon.Font fonts = 1; */
        for (let i = 0; i < message.fonts.length; i++)
            Font.internalBinaryWrite(message.fonts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.GetFontsResponse
 */
export const GetFontsResponse = new GetFontsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Font$Type extends MessageType<Font> {
    constructor() {
        super("ttab.baboon.Font", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "file", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Font>): Font {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.description = "";
        message.file = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Font>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Font): Font {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* bytes file */ 5:
                    message.file = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Font, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* bytes file = 5; */
        if (message.file.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.file);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.Font
 */
export const Font = new Font$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFontsRequest$Type extends MessageType<ListFontsRequest> {
    constructor() {
        super("ttab.baboon.ListFontsRequest", [
            { no: 1, name: "page", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListFontsRequest>): ListFontsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListFontsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFontsRequest): ListFontsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 page */ 1:
                    message.page = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFontsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 page = 1; */
        if (message.page !== 0n)
            writer.tag(1, WireType.Varint).int64(message.page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ListFontsRequest
 */
export const ListFontsRequest = new ListFontsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFontsResponse$Type extends MessageType<ListFontsResponse> {
    constructor() {
        super("ttab.baboon.ListFontsResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FontInfo },
            { no: 2, name: "next_page", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListFontsResponse>): ListFontsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        message.nextPage = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListFontsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFontsResponse): ListFontsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ttab.baboon.FontInfo items */ 1:
                    message.items.push(FontInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 next_page */ 2:
                    message.nextPage = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFontsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ttab.baboon.FontInfo items = 1; */
        for (let i = 0; i < message.items.length; i++)
            FontInfo.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 next_page = 2; */
        if (message.nextPage !== 0n)
            writer.tag(2, WireType.Varint).int64(message.nextPage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ListFontsResponse
 */
export const ListFontsResponse = new ListFontsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FontInfo$Type extends MessageType<FontInfo> {
    constructor() {
        super("ttab.baboon.FontInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FontInfo>): FontInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<FontInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FontInfo): FontInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FontInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.FontInfo
 */
export const FontInfo = new FontInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFontRequest$Type extends MessageType<DeleteFontRequest> {
    constructor() {
        super("ttab.baboon.DeleteFontRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteFontRequest>): DeleteFontRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteFontRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFontRequest): DeleteFontRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFontRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.DeleteFontRequest
 */
export const DeleteFontRequest = new DeleteFontRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFontResponse$Type extends MessageType<DeleteFontResponse> {
    constructor() {
        super("ttab.baboon.DeleteFontResponse", []);
    }
    create(value?: PartialMessage<DeleteFontResponse>): DeleteFontResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteFontResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFontResponse): DeleteFontResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteFontResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.DeleteFontResponse
 */
export const DeleteFontResponse = new DeleteFontResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreICCProfileRequest$Type extends MessageType<StoreICCProfileRequest> {
    constructor() {
        super("ttab.baboon.StoreICCProfileRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<StoreICCProfileRequest>): StoreICCProfileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.description = "";
        message.file = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<StoreICCProfileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreICCProfileRequest): StoreICCProfileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* bytes file */ 3:
                    message.file = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreICCProfileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* bytes file = 3; */
        if (message.file.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.file);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.StoreICCProfileRequest
 */
export const StoreICCProfileRequest = new StoreICCProfileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StoreICCProfileResponse$Type extends MessageType<StoreICCProfileResponse> {
    constructor() {
        super("ttab.baboon.StoreICCProfileResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StoreICCProfileResponse>): StoreICCProfileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<StoreICCProfileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StoreICCProfileResponse): StoreICCProfileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StoreICCProfileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.StoreICCProfileResponse
 */
export const StoreICCProfileResponse = new StoreICCProfileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListICCProfilesRequest$Type extends MessageType<ListICCProfilesRequest> {
    constructor() {
        super("ttab.baboon.ListICCProfilesRequest", [
            { no: 1, name: "page", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListICCProfilesRequest>): ListICCProfilesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListICCProfilesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListICCProfilesRequest): ListICCProfilesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 page */ 1:
                    message.page = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListICCProfilesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 page = 1; */
        if (message.page !== 0n)
            writer.tag(1, WireType.Varint).int64(message.page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ListICCProfilesRequest
 */
export const ListICCProfilesRequest = new ListICCProfilesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListICCProfilesResponse$Type extends MessageType<ListICCProfilesResponse> {
    constructor() {
        super("ttab.baboon.ListICCProfilesResponse", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ICCProfileInfo },
            { no: 2, name: "next_page", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListICCProfilesResponse>): ListICCProfilesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        message.nextPage = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListICCProfilesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListICCProfilesResponse): ListICCProfilesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ttab.baboon.ICCProfileInfo items */ 1:
                    message.items.push(ICCProfileInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 next_page */ 2:
                    message.nextPage = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListICCProfilesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ttab.baboon.ICCProfileInfo items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ICCProfileInfo.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 next_page = 2; */
        if (message.nextPage !== 0n)
            writer.tag(2, WireType.Varint).int64(message.nextPage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ListICCProfilesResponse
 */
export const ListICCProfilesResponse = new ListICCProfilesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ICCProfileInfo$Type extends MessageType<ICCProfileInfo> {
    constructor() {
        super("ttab.baboon.ICCProfileInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ICCProfileInfo>): ICCProfileInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = "";
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<ICCProfileInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ICCProfileInfo): ICCProfileInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ICCProfileInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.ICCProfileInfo
 */
export const ICCProfileInfo = new ICCProfileInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenderArticleRequest$Type extends MessageType<RenderArticleRequest> {
    constructor() {
        super("ttab.baboon.RenderArticleRequest", [
            { no: 1, name: "article_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "layout_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "render_pdf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "render_png", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "png_scale", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RenderArticleRequest>): RenderArticleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.articleUuid = "";
        message.layoutId = "";
        message.renderPdf = false;
        message.renderPng = false;
        message.pngScale = 0n;
        if (value !== undefined)
            reflectionMergePartial<RenderArticleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenderArticleRequest): RenderArticleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string article_uuid */ 1:
                    message.articleUuid = reader.string();
                    break;
                case /* string layout_id */ 2:
                    message.layoutId = reader.string();
                    break;
                case /* bool render_pdf */ 3:
                    message.renderPdf = reader.bool();
                    break;
                case /* bool render_png */ 4:
                    message.renderPng = reader.bool();
                    break;
                case /* int64 png_scale */ 5:
                    message.pngScale = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenderArticleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string article_uuid = 1; */
        if (message.articleUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.articleUuid);
        /* string layout_id = 2; */
        if (message.layoutId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.layoutId);
        /* bool render_pdf = 3; */
        if (message.renderPdf !== false)
            writer.tag(3, WireType.Varint).bool(message.renderPdf);
        /* bool render_png = 4; */
        if (message.renderPng !== false)
            writer.tag(4, WireType.Varint).bool(message.renderPng);
        /* int64 png_scale = 5; */
        if (message.pngScale !== 0n)
            writer.tag(5, WireType.Varint).int64(message.pngScale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.RenderArticleRequest
 */
export const RenderArticleRequest = new RenderArticleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenderArticleResponse$Type extends MessageType<RenderArticleResponse> {
    constructor() {
        super("ttab.baboon.RenderArticleResponse", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "pdf_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "png_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "scribus_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "png_width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "png_height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "images", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MountedImage },
            { no: 8, name: "overflows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Overflow }
        ]);
    }
    create(value?: PartialMessage<RenderArticleResponse>): RenderArticleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.pdfUrl = "";
        message.pngUrl = "";
        message.scribusUrl = "";
        message.pngWidth = 0;
        message.pngHeight = 0;
        message.images = [];
        message.overflows = [];
        if (value !== undefined)
            reflectionMergePartial<RenderArticleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenderArticleResponse): RenderArticleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string pdf_url */ 2:
                    message.pdfUrl = reader.string();
                    break;
                case /* string png_url */ 3:
                    message.pngUrl = reader.string();
                    break;
                case /* string scribus_url */ 4:
                    message.scribusUrl = reader.string();
                    break;
                case /* int32 png_width */ 5:
                    message.pngWidth = reader.int32();
                    break;
                case /* int32 png_height */ 6:
                    message.pngHeight = reader.int32();
                    break;
                case /* repeated ttab.baboon.MountedImage images */ 7:
                    message.images.push(MountedImage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ttab.baboon.Overflow overflows */ 8:
                    message.overflows.push(Overflow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenderArticleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string pdf_url = 2; */
        if (message.pdfUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfUrl);
        /* string png_url = 3; */
        if (message.pngUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pngUrl);
        /* string scribus_url = 4; */
        if (message.scribusUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.scribusUrl);
        /* int32 png_width = 5; */
        if (message.pngWidth !== 0)
            writer.tag(5, WireType.Varint).int32(message.pngWidth);
        /* int32 png_height = 6; */
        if (message.pngHeight !== 0)
            writer.tag(6, WireType.Varint).int32(message.pngHeight);
        /* repeated ttab.baboon.MountedImage images = 7; */
        for (let i = 0; i < message.images.length; i++)
            MountedImage.internalBinaryWrite(message.images[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated ttab.baboon.Overflow overflows = 8; */
        for (let i = 0; i < message.overflows.length; i++)
            Overflow.internalBinaryWrite(message.overflows[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.RenderArticleResponse
 */
export const RenderArticleResponse = new RenderArticleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountedImage$Type extends MessageType<MountedImage> {
    constructor() {
        super("ttab.baboon.MountedImage", [
            { no: 1, name: "frame", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bounding_box", kind: "message", T: () => Rect },
            { no: 3, name: "ppi", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<MountedImage>): MountedImage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frame = "";
        message.ppi = 0;
        if (value !== undefined)
            reflectionMergePartial<MountedImage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountedImage): MountedImage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string frame */ 1:
                    message.frame = reader.string();
                    break;
                case /* ttab.baboon.Rect bounding_box */ 2:
                    message.boundingBox = Rect.internalBinaryRead(reader, reader.uint32(), options, message.boundingBox);
                    break;
                case /* double ppi */ 3:
                    message.ppi = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountedImage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string frame = 1; */
        if (message.frame !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.frame);
        /* ttab.baboon.Rect bounding_box = 2; */
        if (message.boundingBox)
            Rect.internalBinaryWrite(message.boundingBox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double ppi = 3; */
        if (message.ppi !== 0)
            writer.tag(3, WireType.Bit64).double(message.ppi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.MountedImage
 */
export const MountedImage = new MountedImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Overflow$Type extends MessageType<Overflow> {
    constructor() {
        super("ttab.baboon.Overflow", [
            { no: 1, name: "frame", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bounding_box", kind: "message", T: () => Rect }
        ]);
    }
    create(value?: PartialMessage<Overflow>): Overflow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frame = "";
        if (value !== undefined)
            reflectionMergePartial<Overflow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Overflow): Overflow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string frame */ 1:
                    message.frame = reader.string();
                    break;
                case /* ttab.baboon.Rect bounding_box */ 2:
                    message.boundingBox = Rect.internalBinaryRead(reader, reader.uint32(), options, message.boundingBox);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Overflow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string frame = 1; */
        if (message.frame !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.frame);
        /* ttab.baboon.Rect bounding_box = 2; */
        if (message.boundingBox)
            Rect.internalBinaryWrite(message.boundingBox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.Overflow
 */
export const Overflow = new Overflow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rect$Type extends MessageType<Rect> {
    constructor() {
        super("ttab.baboon.Rect", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Rect>): Rect {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<Rect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rect): Rect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                case /* double width */ 3:
                    message.width = reader.double();
                    break;
                case /* double height */ 4:
                    message.height = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        /* double width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Bit64).double(message.width);
        /* double height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Bit64).double(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.Rect
 */
export const Rect = new Rect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEditableArchiveRequest$Type extends MessageType<GetEditableArchiveRequest> {
    constructor() {
        super("ttab.baboon.GetEditableArchiveRequest", [
            { no: 1, name: "render_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetEditableArchiveRequest>): GetEditableArchiveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.renderId = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetEditableArchiveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEditableArchiveRequest): GetEditableArchiveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 render_id */ 1:
                    message.renderId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEditableArchiveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 render_id = 1; */
        if (message.renderId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.renderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.GetEditableArchiveRequest
 */
export const GetEditableArchiveRequest = new GetEditableArchiveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEditableArchiveResponse$Type extends MessageType<GetEditableArchiveResponse> {
    constructor() {
        super("ttab.baboon.GetEditableArchiveResponse", []);
    }
    create(value?: PartialMessage<GetEditableArchiveResponse>): GetEditableArchiveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEditableArchiveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEditableArchiveResponse): GetEditableArchiveResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetEditableArchiveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.GetEditableArchiveResponse
 */
export const GetEditableArchiveResponse = new GetEditableArchiveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutPreviewRequest$Type extends MessageType<LayoutPreviewRequest> {
    constructor() {
        super("ttab.baboon.LayoutPreviewRequest", [
            { no: 1, name: "sla_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "layout", kind: "message", T: () => Document },
            { no: 3, name: "content_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "content", kind: "message", T: () => Document },
            { no: 5, name: "article_layout", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "features", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } }
        ]);
    }
    create(value?: PartialMessage<LayoutPreviewRequest>): LayoutPreviewRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slaFile = "";
        message.contentUuid = "";
        message.articleLayout = "";
        message.features = {};
        if (value !== undefined)
            reflectionMergePartial<LayoutPreviewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayoutPreviewRequest): LayoutPreviewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sla_file */ 1:
                    message.slaFile = reader.string();
                    break;
                case /* newsdoc.Document layout */ 2:
                    message.layout = Document.internalBinaryRead(reader, reader.uint32(), options, message.layout);
                    break;
                case /* string content_uuid */ 3:
                    message.contentUuid = reader.string();
                    break;
                case /* newsdoc.Document content */ 4:
                    message.content = Document.internalBinaryRead(reader, reader.uint32(), options, message.content);
                    break;
                case /* string article_layout */ 5:
                    message.articleLayout = reader.string();
                    break;
                case /* map<string, bool> features */ 6:
                    this.binaryReadMap6(message.features, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: LayoutPreviewRequest["features"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LayoutPreviewRequest["features"] | undefined, val: LayoutPreviewRequest["features"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field ttab.baboon.LayoutPreviewRequest.features");
            }
        }
        map[key ?? ""] = val ?? false;
    }
    internalBinaryWrite(message: LayoutPreviewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sla_file = 1; */
        if (message.slaFile !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.slaFile);
        /* newsdoc.Document layout = 2; */
        if (message.layout)
            Document.internalBinaryWrite(message.layout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string content_uuid = 3; */
        if (message.contentUuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contentUuid);
        /* newsdoc.Document content = 4; */
        if (message.content)
            Document.internalBinaryWrite(message.content, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string article_layout = 5; */
        if (message.articleLayout !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.articleLayout);
        /* map<string, bool> features = 6; */
        for (let k of globalThis.Object.keys(message.features))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).bool(message.features[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.LayoutPreviewRequest
 */
export const LayoutPreviewRequest = new LayoutPreviewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutPreviewResponse$Type extends MessageType<LayoutPreviewResponse> {
    constructor() {
        super("ttab.baboon.LayoutPreviewResponse", [
            { no: 1, name: "pdf_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "images", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MountedImage },
            { no: 3, name: "overflows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Overflow },
            { no: 4, name: "scribus_doc", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<LayoutPreviewResponse>): LayoutPreviewResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfData = new Uint8Array(0);
        message.images = [];
        message.overflows = [];
        message.scribusDoc = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<LayoutPreviewResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayoutPreviewResponse): LayoutPreviewResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pdf_data */ 1:
                    message.pdfData = reader.bytes();
                    break;
                case /* repeated ttab.baboon.MountedImage images */ 2:
                    message.images.push(MountedImage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ttab.baboon.Overflow overflows */ 3:
                    message.overflows.push(Overflow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes scribus_doc */ 4:
                    message.scribusDoc = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayoutPreviewResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes pdf_data = 1; */
        if (message.pdfData.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pdfData);
        /* repeated ttab.baboon.MountedImage images = 2; */
        for (let i = 0; i < message.images.length; i++)
            MountedImage.internalBinaryWrite(message.images[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ttab.baboon.Overflow overflows = 3; */
        for (let i = 0; i < message.overflows.length; i++)
            Overflow.internalBinaryWrite(message.overflows[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes scribus_doc = 4; */
        if (message.scribusDoc.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.scribusDoc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ttab.baboon.LayoutPreviewResponse
 */
export const LayoutPreviewResponse = new LayoutPreviewResponse$Type();
/**
 * @generated ServiceType for protobuf service ttab.baboon.Assets
 */
export const Assets = new ServiceType("ttab.baboon.Assets", [
    { name: "StoreFont", options: {}, I: StoreFontRequest, O: StoreFontResponse },
    { name: "GetFonts", options: {}, I: GetFontsRequest, O: GetFontsResponse },
    { name: "ListFonts", options: {}, I: ListFontsRequest, O: ListFontsResponse },
    { name: "DeleteFont", options: {}, I: DeleteFontRequest, O: DeleteFontResponse },
    { name: "StoreICCProfile", options: {}, I: StoreICCProfileRequest, O: StoreICCProfileResponse },
    { name: "ListICCProfiles", options: {}, I: ListICCProfilesRequest, O: ListICCProfilesResponse }
]);
/**
 * @generated ServiceType for protobuf service ttab.baboon.Print
 */
export const Print = new ServiceType("ttab.baboon.Print", [
    { name: "RenderArticle", options: {}, I: RenderArticleRequest, O: RenderArticleResponse },
    { name: "GetEditableArchive", options: {}, I: GetEditableArchiveRequest, O: GetEditableArchiveResponse },
    { name: "LayoutPreview", options: {}, I: LayoutPreviewRequest, O: LayoutPreviewResponse },
    { name: "CreateFlow", options: {}, I: CreateFlowRequest, O: CreateFlowResponse },
    { name: "CopyArticleToFlow", options: {}, I: CopyArticleToFlowRequest, O: CopyArticleToFlowResponse },
    { name: "GetScribusInfo", options: {}, I: GetScribusInfoRequest, O: GetScribusInfoResponse }
]);
